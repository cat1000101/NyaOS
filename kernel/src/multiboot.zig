// most of this file was generated by zig translate-c from file multiboot.h and was modified by me after Copyright:
//
// multiboot.h - Multiboot header file.
// Copyright (C) 1999,2003,2007,2008,2009,2010  Free Software Foundation, Inc.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to
//  deal in the Software without restriction, including without limitation the
//  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
//  sell copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL ANY
//  DEVELOPER OR DISTRIBUTOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
//  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

const log = @import("std").log;

pub const MULTIBOOT_HEADER: u32 = 1;
pub const MULTIBOOT_SEARCH: u32 = 8192;
pub const MULTIBOOT_HEADER_ALIGN: u32 = 4;
pub const MULTIBOOT_HEADER_MAGIC: u32 = 0x1BADB002;
pub const MULTIBOOT_BOOTLOADER_MAGIC: u32 = 0x2BADB002;

pub const MOD_ALIGN = 0x00001000;
pub const INFO_ALIGN = 0x00000004;

pub const InfoFlags = enum(u32) {
    MEMORY = 0x00000001,
    BOOTDEV = 0x00000002,
    CMDLINE = 0x00000004,
    MODS = 0x00000008,
    AOUT_SYMS = 0x00000010,
    ELF_SHDR = 0x00000020,
    MEM_MAP = 0x00000040,
    DRIVE_INFO = 0x00000080,
    CONFIG_TABLE = 0x00000100,
    BOOT_LOADER_NAME = 0x00000200,
    APM_TABLE = 0x00000400,
    VBE_INFO = 0x00000800,
    FRAMEBUFFER_INFO = 0x00001000,
};

pub const HeaderFlags = enum(u32) {
    PAGE_ALIGN = 0x00000001,
    MEMORY_INFO = 0x00000002,
    VIDEO_MODE = 0x00000004,
    AOUT_KLUDGE = 0x00010000,
};

pub const MULTIBOOT_FRAMEBUFFER_TYPE_INDEXED: u32 = 0;
pub const MULTIBOOT_FRAMEBUFFER_TYPE_RGB: u32 = 1;
pub const MULTIBOOT_FRAMEBUFFER_TYPE_EGA_TEXT: u32 = 2;
pub const MULTIBOOT_MEMORY_AVAILABLE: u32 = 1;
pub const MULTIBOOT_MEMORY_RESERVED: u32 = 2;
pub const MULTIBOOT_MEMORY_ACPI_RECLAIMABLE: u32 = 3;
pub const MULTIBOOT_MEMORY_NVS: u32 = 4;
pub const MULTIBOOT_MEMORY_BADRAM: u32 = 5;

pub const multiboot_header = extern struct {
    magic: u32 = 0,
    flags: u32 = 0,
    checksum: u32 = 0,
    header_addr: u32 = 0,
    load_addr: u32 = 0,
    load_end_addr: u32 = 0,
    bss_end_addr: u32 = 0,
    entry_addr: u32 = 0,
    mode_type: u32 = 0,
    width: u32 = 0,
    height: u32 = 0,
    depth: u32 = 0,
};

pub const multiboot_aout_symbol_table = extern struct {
    tabsize: u32 = 0,
    strsize: u32 = 0,
    addr: u32 = 0,
    reserved: u32 = 0,
};

pub const multiboot_elf_section_header_table = extern struct {
    num: u32 = 0,
    size: u32 = 0,
    addr: u32 = 0,
    shndx: u32 = 0,
};

const debug_format = extern union {
    aout_sym: multiboot_aout_symbol_table,
    elf_sec: multiboot_elf_section_header_table,
};

const palette_format = extern struct {
    framebuffer_palette_addr: u32 = 0,
    framebuffer_palette_num_colors: u16 = 0,
};

const rgb_format = extern struct {
    framebuffer_red_field_position: u8 = 0,
    framebuffer_red_mask_size: u8 = 0,
    framebuffer_green_field_position: u8 = 0,
    framebuffer_green_mask_size: u8 = 0,
    framebuffer_blue_field_position: u8 = 0,
    framebuffer_blue_mask_size: u8 = 0,
};

const color_format = extern union {
    palette: palette_format,
    rgb: rgb_format,
};

pub const multiboot_info = extern struct {
    flags: u32 = 0,
    mem_lower: u32 = 0,
    mem_upper: u32 = 0,
    boot_device: u32 = 0,
    cmdline: u32 = 0,
    mods_count: u32 = 0,
    mods_addr: u32 = 0,
    kernel_debug_info: debug_format, // need to made this generic and deafult being 0?
    mmap_length: u32 = 0,
    mmap_addr: u32 = 0,
    drives_length: u32 = 0,
    drives_addr: u32 = 0,
    config_table: u32 = 0,
    boot_loader_name: u32 = 0,
    apm_table: u32 = 0,
    vbe_control_info: u32 = 0,
    vbe_mode_info: u32 = 0,
    vbe_mode: u16 = 0,
    vbe_interface_seg: u16 = 0,
    vbe_interface_off: u16 = 0,
    vbe_interface_len: u16 = 0,
    framebuffer_addr: u64 = 0,
    framebuffer_pitch: u32 = 0,
    framebuffer_width: u32 = 0,
    framebuffer_height: u32 = 0,
    framebuffer_bpp: u8 = 0,
    framebuffer_type: u8 = 0,
    framebuffer_color: color_format, // need to made this generic and deafult being 0?
};

pub const multiboot_color = extern struct {
    red: u8 = 0,
    green: u8 = 0,
    blue: u8 = 0,
};

pub const multiboot_mmap_entry = extern struct {
    size: u32 align(1) = 0,
    addr: u64 align(1) = 0,
    len: u64 align(1) = 0,
    type: u32 align(1) = 0,
};

pub const multiboot_mod_list = extern struct {
    mod_start: u32 = 0,
    mod_end: u32 = 0,
    cmdline: u32 = 0,
    pad: u32 = 0,
};

pub const multiboot_apm_info = extern struct {
    version: u16 = 0,
    cseg: u16 = 0,
    offset: u32 = 0,
    cseg_16: u16 = 0,
    dseg: u16 = 0,
    flags: u16 = 0,
    cseg_len: u16 = 0,
    cseg_16_len: u16 = 0,
    dseg_len: u16 = 0,
};

// end of generated zig code from multiboot.h

pub var multibootInfo: *multiboot_info = undefined;

pub fn checkMultibootHeader(header: *multiboot_info, magic: u32) bool {
    if (magic != MULTIBOOT_BOOTLOADER_MAGIC) {
        log.err("bootloader multiboot header invalid magic number: {d}\n", .{magic});
        return false;
    }
    if (header.flags >> 6 & 1 == 0) {
        log.err("No memory map provided by GRUB or other multiboot bootloader sad\n", .{});
        return false;
    }

    multibootInfo = header;
    // printRawMemoryMap();
    return true;
}

pub fn getVideoFrameBuffer() ?struct {
    framebuffer_addr: u32,
    framebuffer_pitch: u32,
    framebuffer_bpp: u8,
    framebuffer_rgb: struct {
        redOffset: u8,
        greenOffset: u8,
        blueOffset: u8,
    },
    framebuffer_width: u32,
    framebuffer_height: u32,
} {
    const lmultibootInfo = multibootInfo;
    if (lmultibootInfo.flags & @intFromEnum(InfoFlags.FRAMEBUFFER_INFO) == 0) {
        log.err("No framebuffer info provided by GRUB or other multiboot bootloader sag\n", .{});
        return null;
    }
    if (lmultibootInfo.framebuffer_type != MULTIBOOT_FRAMEBUFFER_TYPE_RGB) {
        log.err("Framebuffer type is not RGB\n", .{});
        return null;
    }
    if (lmultibootInfo.framebuffer_bpp != 32) {
        log.err("Framebuffer bpp is not 32\n", .{});
        return null;
    }
    if (lmultibootInfo.framebuffer_color.rgb.framebuffer_red_mask_size != 8 or lmultibootInfo.framebuffer_color.rgb.framebuffer_blue_mask_size != 8 or lmultibootInfo.framebuffer_color.rgb.framebuffer_green_mask_size != 8) {
        log.err("Framebuffer color mask size is not 8\n", .{});
        return null;
    }

    return .{
        .framebuffer_addr = @truncate(lmultibootInfo.framebuffer_addr),
        .framebuffer_pitch = lmultibootInfo.framebuffer_pitch,
        .framebuffer_bpp = lmultibootInfo.framebuffer_bpp,
        .framebuffer_rgb = .{
            .redOffset = lmultibootInfo.framebuffer_color.rgb.framebuffer_red_field_position,
            .greenOffset = lmultibootInfo.framebuffer_color.rgb.framebuffer_green_field_position,
            .blueOffset = lmultibootInfo.framebuffer_color.rgb.framebuffer_blue_field_position,
        },
        .framebuffer_width = lmultibootInfo.framebuffer_width,
        .framebuffer_height = lmultibootInfo.framebuffer_height,
    };
}

pub fn getModuleInfo() ?[]multiboot_mod_list {
    const header = multibootInfo;
    if (header.mods_addr == 0) {
        log.err("No module list found\n", .{});
        return null;
    }
    const modList = @as([*]multiboot_mod_list, @ptrFromInt(header.mods_addr))[0..header.mods_count];
    for (0..header.mods_count) |i| {
        log.debug(
            "Module {d}: start: 0x{X} end: 0x{X} cmdline: 0x{X}\n",
            .{
                i,
                modList[i].mod_start,
                modList[i].mod_end,
                modList[i].cmdline,
            },
        );
    }
    return modList;
}

fn printRawMemoryMap() void {
    const header = multibootInfo;
    const mmm: [*]multiboot_mmap_entry = @ptrFromInt(header.mmap_addr);
    for (mmm, 0..(header.mmap_length / @sizeOf(multiboot_mmap_entry))) |entry, i| {
        log.info(
            "Memory map entry {d}: size: 0x{X} address: 0x{X} len: 0x{X} type: 0x{X}\n",
            .{
                i,
                entry.size,
                entry.addr,
                entry.len,
                entry.type,
                    //  MULTIBOOT_MEMORY_AVAILABLE              1
                    //  MULTIBOOT_MEMORY_RESERVED               2
                    //  MULTIBOOT_MEMORY_ACPI_RECLAIMABLE       3
                    //  MULTIBOOT_MEMORY_NVS                    4
                    //  MULTIBOOT_MEMORY_BADRAM                 5
            },
        );
    }
}
